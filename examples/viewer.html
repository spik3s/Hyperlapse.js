<!DOCTYPE html>
<html> 
<head> 
	<meta http-equiv="content-type" content="text/html; charset=UTF-8"/> 
	<title>Viewer Example</title> 
	<style>
		body {
			font-family: sans-serif;
			margin: 0;
			overflow: hidden;
		}
		#controls {
			position: absolute;
			top: 10px;
			left: 10px;
			z-index: 10;
			background: rgba(255, 255, 255, 0.9);
			padding: 10px;
			border-radius: 5px;
			opacity: 1;
			transition: opacity 0.3s;
		}
		#map {
			width: 400px;
			height: 300px;
			margin-bottom: 10px;
		}
		#text {
			width: 400px;
			height: 120px;
			padding: 10px;
			background: #eee;
			border: 1px solid #ccc;
			overflow: auto;
			font-family: monospace;
			font-size: 12px;
		}
		#map_form {
			margin-bottom: 10px;
		}
		#context-menu {
			display: none;
			position: absolute;
			z-index: 1000;
			background-color: white;
			border: 1px solid #ccc;
			border-radius: 4px;
			box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
			padding: 5px 0;
			min-width: 120px;
		}
		#context-menu ul {
			list-style: none;
			margin: 0;
			padding: 0;
		}
		#context-menu li {
			padding: 8px 12px;
			cursor: pointer;
			font-size: 14px;
			color: #333;
		}
		#context-menu li:hover {
			background-color: #f0f0f0;
		}
		.custom-map-control-button {
			background-color: #fff;
			border: 2px solid #fff;
			border-radius: 3px;
			box-shadow: 0 2px 6px rgba(0,0,0,.3);
			cursor: pointer;
			margin: 10px;
			text-align: center;
			width: 40px;
			height: 40px;
			display: flex;
			align-items: center;
			justify-content: center;
		}
		.custom-map-control-icon {
			width: 24px;
			height: 24px;
		}
	</style>
	<script type="module">
		import * as dat from 'dat.gui';
		import { Hyperlapse } from '../src/Hyperlapse.js';
		import { HyperlapseExporter } from '../src/HyperlapseExporter.js';
		import { loadGoogleMaps } from '../src/GoogleMapsLoader.js';
		import { AutomationController } from '../src/AutomationController.js';
	
		var start_point, end_point, lookat_point;
		var map, directions_renderer, directions_service, streetview_service, geocoder;
		var start_pin, end_pin, pivot_pin, camera_pin;
		var _elevation = 0;
		var _route_markers = [];
		var _waypoint_markers = [];
		var _waypoints = [];
		var parts;
		var ignore_directions_change = false;
		var automationController;
		var currentAutomationValue = 0;

		function show(msg) {
			document.getElementById("text").innerHTML = msg;
		}

		async function init() {

			const apiKey = import.meta.env.VITE_GOOGLE_MAPS_API_KEY;
			if (!apiKey) {
				console.error("VITE_GOOGLE_MAPS_API_KEY is missing in .env file");
				alert("Please set VITE_GOOGLE_MAPS_API_KEY in .env file");
				return;
			}

			try {
				await loadGoogleMaps(apiKey);
			} catch (e) {
				console.error("Failed to load Google Maps", e);
				return;
			}

			// Initialize points after Google Maps is loaded
			start_point = new google.maps.LatLng(44.3431,6.783936);
			end_point = new google.maps.LatLng(44.340578,6.782684);
			lookat_point = new google.maps.LatLng(44.34232747290594, 6.786460550292986);

			if( window.location.hash ) {
				parts = window.location.hash.substr( 1 ).split( ',' );
				start_point = new google.maps.LatLng(parts[0], parts[1]);
				lookat_point = new google.maps.LatLng(parts[2], parts[3]);
				end_point = new google.maps.LatLng(parts[4], parts[5]);
				_elevation = parts[6] || 0;

				// Parse waypoints (pairs of lat,lng after elevation)
				if (parts.length > 7) {
					for (var i = 7; i < parts.length; i += 2) {
						if (parts[i] && parts[i+1]) {
							_waypoints.push({
								location: new google.maps.LatLng(parts[i], parts[i+1]),
								stopover: true
							});
						}
					}
				}
			} 

			/* Map */

			function snapToRoad(point, callback) {
				var request = { origin: point, destination: point, travelMode: google.maps.TravelMode["DRIVING"] };
				directions_service.route(request, function(response, status) {
					if(status=="OK") callback(response.routes[0].overview_path[0]);
					else callback(null);
				});
			}

			function changeHash() {
				var s = start_pin.position;
				var p = pivot_pin.position;
				var e = end_pin.position;

				var slat = (typeof s.lat === 'function') ? s.lat() : s.lat;
				var slng = (typeof s.lng === 'function') ? s.lng() : s.lng;

				var plat = (typeof p.lat === 'function') ? p.lat() : p.lat;
				var plng = (typeof p.lng === 'function') ? p.lng() : p.lng;

				var elat = (typeof e.lat === 'function') ? e.lat() : e.lat;
				var elng = (typeof e.lng === 'function') ? e.lng() : e.lng;

				var hash = slat + ',' + slng + ','
					+ plat + ',' + plng + ','
					+ elat + ',' + elng + ','
					+ _elevation;

				// Append waypoints
				for (var i = 0; i < _waypoints.length; i++) {
					var wp = _waypoints[i].location;
					var wplat = (typeof wp.lat === 'function') ? wp.lat() : wp.lat;
					var wplng = (typeof wp.lng === 'function') ? wp.lng() : wp.lng;
					hash += ',' + wplat + ',' + wplng;
				}

				window.location.hash = hash;
			}

			var mapOpt = { 
				mapTypeId: google.maps.MapTypeId.ROADMAP,
				center: start_point,
				zoom: 15,
				mapId: "DEMO_MAP_ID" // Required for AdvancedMarkerElement
			};

			map = new google.maps.Map(document.getElementById("map"), mapOpt);
			geocoder = new google.maps.Geocoder();

			// Center on Play Marker Control
			const centerControlDiv = document.createElement("div");
			centerControlDiv.className = "custom-map-control-button";
			centerControlDiv.title = "Center on play marker";

			const centerIcon = document.createElement("div");
			centerIcon.className = "custom-map-control-icon";
			centerIcon.innerHTML = `
				<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
					<circle cx="12" cy="12" r="10" stroke="#666" stroke-width="2"/>
					<circle cx="12" cy="12" r="4" fill="#666"/>
					<line x1="12" y1="2" x2="12" y2="6" stroke="#666" stroke-width="2"/>
					<line x1="12" y1="18" x2="12" y2="22" stroke="#666" stroke-width="2"/>
					<line x1="2" y1="12" x2="6" y2="12" stroke="#666" stroke-width="2"/>
					<line x1="18" y1="12" x2="22" y2="12" stroke="#666" stroke-width="2"/>
				</svg>
			`;
			centerControlDiv.appendChild(centerIcon);

			centerControlDiv.addEventListener("click", () => {
				// Use .position for AdvancedMarkerElement, or .getPosition() for legacy Marker (fallback)
				const pos = camera_pin && (camera_pin.position || (camera_pin.getPosition && camera_pin.getPosition()));
				if (pos) {
					map.setCenter(pos);
				}
			});

			map.controls[google.maps.ControlPosition.RIGHT_BOTTOM].push(centerControlDiv);

			var overlay = new google.maps.StreetViewCoverageLayer();
			overlay.setMap(map);

			directions_service = new google.maps.DirectionsService();
			directions_renderer = new google.maps.DirectionsRenderer({
				draggable: true,
				markerOptions: { opacity: 0 }, // Hide default markers but keep them draggable
				preserveViewport: true
			});
			directions_renderer.setMap(map);

			function clearRouteMarkers() {
				var marker;
				while(_route_markers.length > 0) {
					marker = _route_markers.pop();
					marker.setMap(null);
				}
			}

			directions_renderer.addListener('directions_changed', function() {
				var result = directions_renderer.getDirections();
				if (!result || !result.routes || !result.routes.length) return;

				var route = result.routes[0];
				var legs = route.legs;

				// Update Start and End based on route result
				var start_loc = legs[0].start_location;
				var end_loc = legs[legs.length - 1].end_location;

				start_point = start_loc;
				end_point = end_loc;
				start_pin.position = start_point;
				end_pin.position = end_point;

				// Extract waypoints from legs (end_location of all legs except the last one)
				_waypoints = [];
				// Clear existing waypoint markers
				for (var k = 0; k < _waypoint_markers.length; k++) {
					_waypoint_markers[k].map = null;
				}
				_waypoint_markers = [];

				for (var i = 0; i < legs.length - 1; i++) {
					var wp_loc = legs[i].end_location;
					_waypoints.push({
						location: wp_loc,
						stopover: true
					});

					// Create Orange marker for waypoint
					var wp_pin = new google.maps.marker.AdvancedMarkerElement({
						position: wp_loc,
						gmpDraggable: false, // Rely on underlying renderer for dragging
						map: map,
						content: new google.maps.marker.PinElement({
							background: '#FF9800', // Orange
							borderColor: '#EF6C00',
							glyphColor: 'white',
						}).element,
					});
					// Pass events to underlying marker
					wp_pin.element.style.pointerEvents = 'none';
					_waypoint_markers.push(wp_pin);
				}

				changeHash();

				if (ignore_directions_change) return;

				clearRouteMarkers();
				hyperlapse.generate({ route: result });
			});

			camera_pin = new google.maps.marker.AdvancedMarkerElement({
				position: start_point,
				map: map,
				content: new google.maps.marker.PinElement({
					background: '#2196F3', // Blue
					borderColor: '#1565C0',
					glyphColor: 'white',
				}).element,
			});

			start_pin = new google.maps.marker.AdvancedMarkerElement({
				position: start_point,
				gmpDraggable: true,
				map: map,
				content: new google.maps.marker.PinElement({
					background: '#4CAF50', // Green
					borderColor: '#2E7D32',
					glyphColor: 'white',
				}).element,
			});

			start_pin.addEventListener('dragend', function (event) {
				start_point = start_pin.position;
				o.generate();
			});

			end_pin = new google.maps.marker.AdvancedMarkerElement({
				position: end_point,
				gmpDraggable: true,
				map: map,
				content: new google.maps.marker.PinElement({
					background: '#F44336', // Red
					borderColor: '#C62828',
					glyphColor: 'white',
				}).element,
			});

			end_pin.addEventListener('dragend', function (event) {
				end_point = end_pin.position;
				o.generate();
			});

			pivot_pin = new google.maps.marker.AdvancedMarkerElement({
				position: lookat_point,
				gmpDraggable: true,
				map: map,
				content: new google.maps.marker.PinElement({
					background: '#FFEB3B', // Yellow
					borderColor: '#FBC02D',
					glyphColor: 'black',
				}).element,
			});

			pivot_pin.addEventListener('dragend', function (event) {
				hyperlapse.setLookat( pivot_pin.position );
				changeHash();
			});

			// Draw initial waypoint markers if loaded from hash
			if (_waypoints.length > 0) {
				for (var i = 0; i < _waypoints.length; i++) {
					var wp_pin = new google.maps.marker.AdvancedMarkerElement({
						position: _waypoints[i].location,
						gmpDraggable: false,
						map: map,
						content: new google.maps.marker.PinElement({
							background: '#FF9800', // Orange
							borderColor: '#EF6C00',
							glyphColor: 'white',
						}).element,
					});
					wp_pin.element.style.pointerEvents = 'none';
					_waypoint_markers.push(wp_pin);
				}
			}

			function findAddress(address) {
				geocoder.geocode( { 'address': address}, function(results, status) {
					if (status == google.maps.GeocoderStatus.OK) {
						map.setCenter(results[0].geometry.location);
						o.drop_pins();
					} else {
						show( "Geocode was not successful for the following reason: " + status );
					}
				});
			}

			var search = document.getElementById( 'searchButton' );
			search.addEventListener( 'click', function( event ) {
				event.preventDefault();
				findAddress( document.getElementById("address").value );
			}, false );


			/* Hyperlapse */

			var pano = document.getElementById('pano');
			var is_moving = false;
			var px, py;
			var onPointerDownPointerX=0, onPointerDownPointerY=0;

			// Automation Controller
			var automationPanel = document.getElementById('automation_panel');
			automationController = new AutomationController(automationPanel);

			var hyperlapse = new Hyperlapse(pano, {
				lookat: lookat_point,
				fov: 80,
				millis: 50,
				width: window.innerWidth,
				height: window.innerHeight,
				zoom: 1,
				use_lookat: true,
				distance_between_points: 5,
				max_points: 100,
				elevation: _elevation,
				apiKey: apiKey
			});
			
			

			hyperlapse.onError = function(e) {
				show( "ERROR: "+ e.message );
			};

			function createYellowCircleElement() {
				const el = document.createElement('div');
				el.style.width = '10px';
				el.style.height = '10px';
				el.style.backgroundColor = '#FFEB3B'; // Yellow
				el.style.border = '2px solid #FBC02D'; // Darker yellow border
				el.style.borderRadius = '50%';
				el.style.cursor = 'pointer';
				return el;
			}

			// Context Menu logic
			const contextMenu = document.getElementById('context-menu');
			const skipItem = document.getElementById('menu-skip');
			const includeItem = document.getElementById('menu-include');
			let currentContextPoint = null;
			let currentContextMarkerElement = null;

			function showContextMenu(x, y, point, markerElement) {
				currentContextPoint = point;
				currentContextMarkerElement = markerElement;

				if (point.is_skipped) {
					skipItem.style.display = 'none';
					includeItem.style.display = 'block';
				} else {
					skipItem.style.display = 'block';
					includeItem.style.display = 'none';
				}

				contextMenu.style.left = x + 'px';
				contextMenu.style.top = y + 'px';
				contextMenu.style.display = 'block';
			}

			function hideContextMenu() {
				contextMenu.style.display = 'none';
				currentContextPoint = null;
				currentContextMarkerElement = null;
			}

			document.addEventListener('click', hideContextMenu);

			// Prevent context menu from closing when clicking inside it
			contextMenu.addEventListener('click', (e) => e.stopPropagation());

			skipItem.addEventListener('click', () => {
				if (currentContextPoint && currentContextMarkerElement) {
					currentContextPoint.is_skipped = true;
					currentContextMarkerElement.style.backgroundColor = '#9E9E9E'; // Gray
					currentContextMarkerElement.style.borderColor = '#616161';
				}
				hideContextMenu();
			});

			includeItem.addEventListener('click', () => {
				if (currentContextPoint && currentContextMarkerElement) {
					currentContextPoint.is_skipped = false;
					currentContextMarkerElement.style.backgroundColor = '#FFEB3B'; // Yellow
					currentContextMarkerElement.style.borderColor = '#FBC02D';
				}
				hideContextMenu();
			});


			hyperlapse.onRouteProgress = function(e) {
				const el = createYellowCircleElement();
				var marker = new google.maps.marker.AdvancedMarkerElement({
					position: e.point.location,
					gmpDraggable: true,
					content: el,
					map: map
				});

				// Attach context menu listener to the marker element
				el.addEventListener('contextmenu', function(event) {
					event.preventDefault();
					event.stopPropagation();
					showContextMenu(event.clientX, event.clientY, e.point, el);
				});

				marker.addEventListener('dragend', function (event) {
					_waypoints.push({
						location: marker.position,
						stopover: true
					});
					o.generate();
				});

				_route_markers.push( marker );
			};

			hyperlapse.onRouteComplete = function(e) {
				ignore_directions_change = true;
				directions_renderer.setDirections(e.response);
				ignore_directions_change = false;
				show( "Number of Points: "+ hyperlapse.length() );
				hyperlapse.load();
			};

			hyperlapse.onLoadProgress = function(e) {
				show( "Loading: "+ (e.position+1) +" of "+ hyperlapse.length() );
			};

			hyperlapse.onLoadComplete = function(e) {
				show( "" +
					"Start: " + start_pin.position.toString() +
					"<br>End: " + end_pin.position.toString() +
					"<br>Lookat: " + pivot_pin.position.toString() +
					"<br>Ready." );
			};

			hyperlapse.onFrame = function(e) {
				show( "" +
					"Start: " + start_pin.position.toString() +
					"<br>End: " + end_pin.position.toString() +
					"<br>Lookat: " + pivot_pin.position.toString() +
					"<br>Position: "+ (e.position+1) +" of "+ hyperlapse.length() );
				camera_pin.position = e.point.location;

				if (o.mode === 'Automation' && hyperlapse.length() > 0) {
					const t = e.position / (hyperlapse.length() - 1);
					let targetYaw = automationController.getValueAt(t);

					if (o.smoothing > 0) {
						// Simple lerp for smoothing
						// Adjust speed based on smoothing factor
						const alpha = 1 - o.smoothing;
						currentAutomationValue += (targetYaw - currentAutomationValue) * alpha;
					} else {
						currentAutomationValue = targetYaw;
					}
					hyperlapse.position.x = currentAutomationValue;
					o.position_x = currentAutomationValue; // Sync GUI

					// Update playhead
					automationController.setPlayhead(t);
				}
			};

			pano.addEventListener( 'mousedown', function(e){
				e.preventDefault();

				// Disable manual drag in Automation mode
				if (o.mode === 'Automation') return;

				is_moving = true;

				onPointerDownPointerX = e.clientX;
				onPointerDownPointerY = e.clientY;

				px = hyperlapse.position.x;
				py = hyperlapse.position.y;

			}, false );

			pano.addEventListener( 'mousemove', function(e){
				e.preventDefault();
				var f = hyperlapse.fov() / 500;

				if ( is_moving ) {
					var dx = ( onPointerDownPointerX - e.clientX ) * f;
					var dy = ( e.clientY - onPointerDownPointerY ) * f;
					hyperlapse.position.x = px + dx; // reversed dragging direction (thanks @mrdoob!)
					hyperlapse.position.y = py + dy;

					o.position_x = hyperlapse.position.x;
					o.position_y = hyperlapse.position.y;
				}

			}, false );

			pano.addEventListener( 'mouseup', function(){
				is_moving = false;

				hyperlapse.position.x = px;
				//hyperlapse.position.y = py;
			}, false );

			

			/* Dat GUI */

			var gui = new dat.GUI();

			var o = {
				mode: 'LookAt',
				smoothing: 0,
				distance_between_points:10, 
				max_points:100, 
				fov: 80, 
				zoom: 1,
				elevation:Math.floor(_elevation), 
				tilt:0, 
				millis:50, 
				offset_x:0,
				offset_y:0,
				offset_z:0,
				position_x:0,
				position_y:0,
				use_lookat:true,
				screen_width: window.innerWidth,
				screen_height: window.innerHeight,
				radius: 15,
				google_only: false,
				preference: 'nearest',
				buffer_size: 10,
				generate:function(){
					show( "Generating route..." );

					clearRouteMarkers();

					if(start_pin) start_point = start_pin.position;
					if(end_pin) end_point = end_pin.position;
					if(pivot_pin) {
						lookat_point = pivot_pin.position;
						hyperlapse.setLookat(lookat_point);
					}

					if (!start_point || !end_point) {
						console.log("Start or End point not defined.");
						return;
					}

					var request = {
						origin: start_point, 
						destination: end_point, 
						waypoints: _waypoints,
						travelMode: google.maps.TravelMode.DRIVING
					};

					directions_service.route(request, function(response, status) {
						if (status == google.maps.DirectionsStatus.OK) {   
							hyperlapse.generate({route: response});
						} else {
							console.log(status);
						}
					})
				},
				drop_pins:function(){
					var bounds = map.getBounds();
					var top_left = bounds.getNorthEast();
					var bot_right = bounds.getSouthWest();
					var hdif = Math.abs(top_left.lng() - bot_right.lng());
					var spacing = hdif/4;

					var center = map.getCenter();
					var c1 = new google.maps.LatLng(center.lat(), center.lng()-spacing);
					var c2 = new google.maps.LatLng(center.lat(), center.lng());
					var c3 = new google.maps.LatLng(center.lat(), center.lng()+spacing);

					hyperlapse.lookat = c2;
					pivot_pin.position = c2;

					snapToRoad(c1, function(result1) {
						start_pin.position = result1;
						start_point = result1;

						snapToRoad(c3, function(result3) {
							end_pin.position = result3;
							end_point = result3;
							// Clear waypoints on new drop
							_waypoints = [];
							for (var k = 0; k < _waypoint_markers.length; k++) {
								_waypoint_markers[k].map = null;
							}
							_waypoint_markers = [];
							changeHash();
							// o.generate(); // Let user generate manually? Or call it? Original didn't call generate.
						});
					});
				}
			};


			var scn = gui.addFolder('screen');
			scn.add(o, 'screen_width', window.innerHeight).listen();
			scn.add(o, 'screen_height', window.innerHeight).listen();

			var parameters = gui.addFolder('parameters');

			var distance_between_points_control = parameters.add(o, 'distance_between_points', 5, 100);
			distance_between_points_control.onChange(function(value) {
				hyperlapse.setDistanceBetweenPoint(value);
			});

			var max_points = parameters.add(o, 'max_points', 10, 300);
			max_points.onChange(function(value) {
				hyperlapse.setMaxPoints(value);
			});

			var zoom_control = parameters.add(o, 'zoom', 0, 5).step(1);
			zoom_control.onChange(function(value) {
				hyperlapse.setZoom(value);
			});

			var fov_control = parameters.add(o, 'fov', 1, 180);
			fov_control.onChange(function(value) {
				hyperlapse.setFOV(value);
			});

			var pitch_control = parameters.add(o, 'elevation', -1000, 1000);
			pitch_control.onChange(function(value) {
				_elevation = value;
				hyperlapse.elevation_offset = value;
				changeHash();
			});

			var millis_control = parameters.add(o, 'millis', 10, 250);
			millis_control.onChange(function(value) {
				hyperlapse.millis = value;
			});

			var offset_x_control = parameters.add(o, 'offset_x', -360, 360);
			offset_x_control.onChange(function(value) {
				hyperlapse.offset.x = value;
			});

			var offset_y_control = parameters.add(o, 'offset_y', -180, 180);
			offset_y_control.onChange(function(value) {
				hyperlapse.offset.y = value;
			});

			var offset_z_control = parameters.add(o, 'offset_z', -360, 360);
			offset_z_control.onChange(function(value) {
				hyperlapse.offset.z = value;
			});

			var position_x_control = parameters.add(o, 'position_x', -360, 360).listen();
			position_x_control.onChange(function(value) {
				hyperlapse.position.x = value;
			});

			var position_y_control = parameters.add(o, 'position_y', -180, 180).listen();
			position_y_control.onChange(function(value) {
				hyperlapse.position.y = value;
			});

			var tilt_control = parameters.add(o, 'tilt', -Math.PI, Math.PI);
			tilt_control.onChange(function(value) {
				hyperlapse.tilt = value;
			});

			// var lookat_control = parameters.add(o, 'use_lookat')
			// lookat_control.onChange(function(value) {
			// 	hyperlapse.use_lookat = value;
			// });
			// Replaced by Mode control

			var mode_control = parameters.add(o, 'mode', ['Default', 'LookAt', 'Automation']);
			mode_control.onChange(function(value) {
				if (value === 'LookAt') {
					hyperlapse.use_lookat = true;
					document.getElementById('automation_panel').style.display = 'none';
				} else if (value === 'Automation') {
					hyperlapse.use_lookat = false;
					document.getElementById('automation_panel').style.display = 'block';
					automationController.resize();
				} else { // Default
					hyperlapse.use_lookat = false;
					document.getElementById('automation_panel').style.display = 'none';
				}
			});

			// Initialize mode state
			if (o.mode === 'LookAt') {
				hyperlapse.use_lookat = true;
				document.getElementById('automation_panel').style.display = 'none';
			} else if (o.mode === 'Automation') {
				hyperlapse.use_lookat = false;
				document.getElementById('automation_panel').style.display = 'block';
			} else {
				hyperlapse.use_lookat = false;
				document.getElementById('automation_panel').style.display = 'none';
			}

			var smoothing_control = parameters.add(o, 'smoothing', 0, 0.95).name('Auto Smooth');
			smoothing_control.onChange(function(value) {
				automationController.smoothing = value; // Pass if needed, though we use o.smoothing directly
			});

			var radius_control = parameters.add(o, 'radius', 5, 100);
			radius_control.onChange(function(value) {
				hyperlapse.setRadius(value);
			});

			var google_only_control = parameters.add(o, 'google_only');
			google_only_control.onChange(function(value) {
				hyperlapse.setSource(value ? google.maps.StreetViewSource.GOOGLE : google.maps.StreetViewSource.DEFAULT);
			});

			var preference_control = parameters.add(o, 'preference', ['nearest', 'best']);
			preference_control.onChange(function(value) {
				hyperlapse.setPreference(value === 'best' ? google.maps.StreetViewPreference.BEST : google.maps.StreetViewPreference.NEAREST);
			});

			var buffer_control = parameters.add(o, 'buffer_size', 5, 50).step(1);
			buffer_control.onChange(function(value) {
				hyperlapse.buffer_size = value;
			});

			parameters.open();
			

			var play_controls = gui.addFolder('play controls');
			play_controls.add(hyperlapse, 'play');
			play_controls.add(hyperlapse, 'pause');
			play_controls.add(hyperlapse, 'next');
			play_controls.add(hyperlapse, 'prev');
			play_controls.open();

			var exporter = new HyperlapseExporter(hyperlapse);
			var export_params = {
				ratio: 'screen',
				mode: 'loop',
				export: function() {
					exporter.export({
						ratio: export_params.ratio,
						mode: export_params.mode
					});
				}
			};

			var export_folder = gui.addFolder('Export');
			export_folder.add(export_params, 'ratio', ['screen', '16:9', '9:16']);
			export_folder.add(export_params, 'mode', ['single', 'loop']);
			export_folder.add(export_params, 'export').name('Export Video');
			export_folder.open();

			gui.add(o, 'drop_pins');
			gui.add(o, 'generate');
			gui.add(hyperlapse, 'load');


			window.addEventListener('resize', function(){
				hyperlapse.setSize(window.innerWidth, window.innerHeight);
				o.screen_width = window.innerWidth;
				o.screen_height = window.innerHeight;
			}, false);

			var show_ui = true;
			document.addEventListener( 'keydown', onKeyDown, false );
			function onKeyDown ( event ) {

				if (event.target.tagName === 'INPUT') return;

				switch( event.keyCode ) {
					case 72: /* H */
						show_ui = !show_ui;
						document.getElementById("controls").style.opacity = (show_ui)?1:0;
						break;

					case 190: /* > */
						hyperlapse.next();
						break;

					case 188: /* < */
						hyperlapse.prev();
						break;
				}

			};

			o.generate();
		}

		window.onload = init;
	</script> 
</head> 
<body> 
	<div id="pano" style="position: absolute; left: 0; top: 0; right: 0; bottom: 0; z-index:-1;"></div>
	<div id="controls">
		<div id="map"></div>
		<div id="automation_panel" style="width: 400px; height: 150px; display: none; margin-bottom: 10px; background: #333; border: 1px solid #666;"></div>
		<div id="controls_form">
			<form id="map_form">
				<input type="text" name="address" id="address" placeholder="Search address..." />
				<button type="submit" id="searchButton" >Search</button>
			</form>
		</div>
		<div id="text"></div>
	</div>
	
	<div id="context-menu">
		<ul>
			<li id="menu-skip">Skip the frame</li>
			<li id="menu-include">Include frame</li>
		</ul>
	</div>
</body> 
</html>